// Code generated by "core generate"; DO NOT EDIT.

package parser

import (
	"cogentcore.org/core/enums"
)

var _ActionsValues = []Actions{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

// ActionsN is the highest valid value for type Actions, plus one.
const ActionsN Actions = 10

var _ActionsValueMap = map[string]Actions{`ChangeToken`: 0, `AddSymbol`: 1, `PushScope`: 2, `PushNewScope`: 3, `PopScope`: 4, `PopScopeReg`: 5, `AddDetail`: 6, `AddType`: 7, `PushStack`: 8, `PopStack`: 9}

var _ActionsDescMap = map[Actions]string{0: `ChangeToken changes the token to the Tok specified in the Act action`, 1: `AddSymbol means add name as a symbol, using current scoping and token type or the token specified in the Act action if != None`, 2: `PushScope means look for an existing symbol of given name to push onto current scope -- adding a new one if not found -- does not add new item to overall symbol list. This is useful for e.g., definitions of methods on a type, where this is not the definition of the type itself.`, 3: `PushNewScope means add a new symbol to the list and also push onto scope stack, using given token type or the token specified in the Act action if != None`, 4: `PopScope means remove the most recently added scope item`, 5: `PopScopeReg means remove the most recently added scope item, and also updates the source region for that item based on final SrcReg from corresponding Ast node -- for &#34;definitional&#34; scope`, 6: `AddDetail adds src at given path as detail info for the last-added symbol if there is already something there, a space is added for this new addition`, 7: `AddType Adds a type with the given name -- sets the Ast node for this rule and actual type is resolved later in a second language-specific pass`, 8: `PushStack adds name to stack -- provides context-sensitivity option for optimizing and ambiguity resolution`, 9: `PopStack pops the stack`}

var _ActionsMap = map[Actions]string{0: `ChangeToken`, 1: `AddSymbol`, 2: `PushScope`, 3: `PushNewScope`, 4: `PopScope`, 5: `PopScopeReg`, 6: `AddDetail`, 7: `AddType`, 8: `PushStack`, 9: `PopStack`}

// String returns the string representation of this Actions value.
func (i Actions) String() string { return enums.String(i, _ActionsMap) }

// SetString sets the Actions value from its string representation,
// and returns an error if the string is invalid.
func (i *Actions) SetString(s string) error {
	return enums.SetString(i, s, _ActionsValueMap, "Actions")
}

// Int64 returns the Actions value as an int64.
func (i Actions) Int64() int64 { return int64(i) }

// SetInt64 sets the Actions value from an int64.
func (i *Actions) SetInt64(in int64) { *i = Actions(in) }

// Desc returns the description of the Actions value.
func (i Actions) Desc() string { return enums.Desc(i, _ActionsDescMap) }

// ActionsValues returns all possible values for the type Actions.
func ActionsValues() []Actions { return _ActionsValues }

// Values returns all possible values for the type Actions.
func (i Actions) Values() []enums.Enum { return enums.Values(_ActionsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Actions) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Actions) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Actions") }

var _AstActsValues = []AstActs{0, 1, 2, 3, 4}

// AstActsN is the highest valid value for type AstActs, plus one.
const AstActsN AstActs = 5

var _AstActsValueMap = map[string]AstActs{`NoAst`: 0, `AddAst`: 1, `SubAst`: 2, `AnchorAst`: 3, `AnchorFirstAst`: 4}

var _AstActsDescMap = map[AstActs]string{0: `NoAst means don&#39;t create an Ast node for this rule`, 1: `AddAst means create an Ast node for this rule, adding it to the current anchor Ast. Any sub-rules within this rule are *not* added as children of this node -- see SubAst and AnchorAst. This is good for token-only terminal nodes and list elements that should be added to a list.`, 2: `SubAst means create an Ast node and add all the elements of *this rule* as children of this new node (including sub-rules), *except* for the very last rule which is assumed to be a recursive rule -- that one goes back up to the parent node. This is good for adding more complex elements with sub-rules to a recursive list, without creating a new hierarchical depth level for every such element.`, 3: `AnchorAst means create an Ast node and set it as the anchor that subsequent sub-nodes are added into. This is for a new hierarchical depth level where everything under this rule gets organized.`, 4: `AnchorFirstAst means create an Ast node and set it as the anchor that subsequent sub-nodes are added into, *only* if this is the first time that this rule has matched within the current sequence (i.e., if the parent of this rule is the same rule then don&#39;t add a new Ast node). This is good for starting a new list of recursively defined elements, without creating increasing depth levels.`}

var _AstActsMap = map[AstActs]string{0: `NoAst`, 1: `AddAst`, 2: `SubAst`, 3: `AnchorAst`, 4: `AnchorFirstAst`}

// String returns the string representation of this AstActs value.
func (i AstActs) String() string { return enums.String(i, _AstActsMap) }

// SetString sets the AstActs value from its string representation,
// and returns an error if the string is invalid.
func (i *AstActs) SetString(s string) error {
	return enums.SetString(i, s, _AstActsValueMap, "AstActs")
}

// Int64 returns the AstActs value as an int64.
func (i AstActs) Int64() int64 { return int64(i) }

// SetInt64 sets the AstActs value from an int64.
func (i *AstActs) SetInt64(in int64) { *i = AstActs(in) }

// Desc returns the description of the AstActs value.
func (i AstActs) Desc() string { return enums.Desc(i, _AstActsDescMap) }

// AstActsValues returns all possible values for the type AstActs.
func AstActsValues() []AstActs { return _AstActsValues }

// Values returns all possible values for the type AstActs.
func (i AstActs) Values() []enums.Enum { return enums.Values(_AstActsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i AstActs) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *AstActs) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "AstActs") }

var _StepsValues = []Steps{0, 1, 2, 3, 4}

// StepsN is the highest valid value for type Steps, plus one.
const StepsN Steps = 5

var _StepsValueMap = map[string]Steps{`Match`: 0, `SubMatch`: 1, `NoMatch`: 2, `Run`: 3, `RunAct`: 4}

var _StepsDescMap = map[Steps]string{0: `Match happens when a rule matches`, 1: `SubMatch is when a sub-rule within a rule matches`, 2: `NoMatch is when the rule fails to match (recorded at first non-match, which terminates matching process`, 3: `Run is when the rule is running and iterating through its sub-rules`, 4: `RunAct is when the rule is running and performing actions`}

var _StepsMap = map[Steps]string{0: `Match`, 1: `SubMatch`, 2: `NoMatch`, 3: `Run`, 4: `RunAct`}

// String returns the string representation of this Steps value.
func (i Steps) String() string { return enums.String(i, _StepsMap) }

// SetString sets the Steps value from its string representation,
// and returns an error if the string is invalid.
func (i *Steps) SetString(s string) error { return enums.SetString(i, s, _StepsValueMap, "Steps") }

// Int64 returns the Steps value as an int64.
func (i Steps) Int64() int64 { return int64(i) }

// SetInt64 sets the Steps value from an int64.
func (i *Steps) SetInt64(in int64) { *i = Steps(in) }

// Desc returns the description of the Steps value.
func (i Steps) Desc() string { return enums.Desc(i, _StepsDescMap) }

// StepsValues returns all possible values for the type Steps.
func StepsValues() []Steps { return _StepsValues }

// Values returns all possible values for the type Steps.
func (i Steps) Values() []enums.Enum { return enums.Values(_StepsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Steps) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Steps) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Steps") }
