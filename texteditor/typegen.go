// Code generated by "core generate"; DO NOT EDIT.

package texteditor

import (
	"image"
	"io"
	"time"

	"cogentcore.org/core/paint"
	"cogentcore.org/core/styles/units"
	"cogentcore.org/core/tree"
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/texteditor.Buffer", IDName: "buffer", Doc: "Buffer is a buffer of text, which can be viewed by [Editor](s).\nIt holds the raw text lines (in original string and rune formats,\nand marked-up from syntax highlighting), and sends signals for making\nedits to the text and coordinating those edits across multiple views.\nEditors always only view a single buffer, so they directly call methods\non the buffer to drive updates, which are then broadcast.\nIt also has methods for loading and saving buffers to files.\nUnlike GUI widgets, its methods generally send events, without an\nexplicit Event suffix.\nInternally, the buffer represents new lines using \\n = LF, but saving\nand loading can deal with Windows/DOS CRLF format.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Methods: []types.Method{{Name: "Open", Doc: "Open loads the given file into the buffer.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "Revert", Doc: "Revert re-opens text from the current file,\nif the filename is set; returns false if not.\nIt uses an optimized diff-based update to preserve\nexisting formatting, making it very fast if not very different.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"bool"}}, {Name: "SaveAs", Doc: "SaveAs saves the current text into given file; does an editDone first to save edits\nand checks for an existing file; if it does exist then prompts to overwrite or not.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}}, {Name: "Save", Doc: "Save saves the current text into the current filename associated with this buffer.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"error"}}}, Embeds: []types.Field{{Name: "Lines"}}, Fields: []types.Field{{Name: "Filename", Doc: "Filename is the filename of the file that was last loaded or saved.\nIt is used when highlighting code."}, {Name: "Autosave", Doc: "Autosave specifies whether the file should be automatically\nsaved after changes are made."}, {Name: "Info", Doc: "Info is the full information about the current file."}, {Name: "LineColors", Doc: "LineColors are the colors to use for rendering circles\nnext to the line numbers of certain lines."}, {Name: "editors", Doc: "editors are the editors that are currently viewing this buffer."}, {Name: "posHistory", Doc: "posHistory is the history of cursor positions.\nIt can be used to move back through them."}, {Name: "Complete", Doc: "Complete is the functions and data for text completion."}, {Name: "spell", Doc: "spell is the functions and data for spelling correction."}, {Name: "currentEditor", Doc: "currentEditor is the current text editor, such as the one that initiated the\nComplete or Correct process. The cursor position in this view is updated, and\nit is reset to nil after usage."}, {Name: "listeners", Doc: "listeners is used for sending standard system events.\nChange is sent for BufferDone, BufferInsert, and BufferDelete."}, {Name: "autoSaving", Doc: "autoSaving is used in atomically safe way to protect autosaving"}, {Name: "notSaved", Doc: "notSaved indicates if the text has been changed (edited) relative to the\noriginal, since last Save.  This can be true even when changed flag is\nfalse, because changed is cleared on EditDone, e.g., when texteditor\nis being monitored for OnChange and user does Control+Enter.\nUse IsNotSaved() method to query state."}, {Name: "fileModOK", Doc: "fileModOK have already asked about fact that file has changed since being\nopened, user is ok"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/texteditor.DiffEditor", IDName: "diff-editor", Doc: "DiffEditor presents two side-by-side [Editor]s showing the differences\nbetween two files (represented as lines of strings).", Methods: []types.Method{{Name: "saveFileA", Doc: "saveFileA saves the current state of file A to given filename", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"fname"}}, {Name: "saveFileB", Doc: "saveFileB saves the current state of file B to given filename", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"fname"}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "FileA", Doc: "first file name being compared"}, {Name: "FileB", Doc: "second file name being compared"}, {Name: "RevisionA", Doc: "revision for first file, if relevant"}, {Name: "RevisionB", Doc: "revision for second file, if relevant"}, {Name: "bufferA", Doc: "[Buffer] for A showing the aligned edit view"}, {Name: "bufferB", Doc: "[Buffer] for B showing the aligned edit view"}, {Name: "alignD", Doc: "aligned diffs records diff for aligned lines"}, {Name: "diffs", Doc: "diffs applied"}, {Name: "inInputEvent"}}})

// NewDiffEditor returns a new [DiffEditor] with the given optional parent:
// DiffEditor presents two side-by-side [Editor]s showing the differences
// between two files (represented as lines of strings).
func NewDiffEditor(parent ...tree.Node) *DiffEditor { return tree.New[DiffEditor](parent...) }

// SetFileA sets the [DiffEditor.FileA]:
// first file name being compared
func (t *DiffEditor) SetFileA(v string) *DiffEditor { t.FileA = v; return t }

// SetFileB sets the [DiffEditor.FileB]:
// second file name being compared
func (t *DiffEditor) SetFileB(v string) *DiffEditor { t.FileB = v; return t }

// SetRevisionA sets the [DiffEditor.RevisionA]:
// revision for first file, if relevant
func (t *DiffEditor) SetRevisionA(v string) *DiffEditor { t.RevisionA = v; return t }

// SetRevisionB sets the [DiffEditor.RevisionB]:
// revision for second file, if relevant
func (t *DiffEditor) SetRevisionB(v string) *DiffEditor { t.RevisionB = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/texteditor.DiffTextEditor", IDName: "diff-text-editor", Doc: "DiffTextEditor supports double-click based application of edits from one\nbuffer to the other.", Embeds: []types.Field{{Name: "Editor"}}})

// NewDiffTextEditor returns a new [DiffTextEditor] with the given optional parent:
// DiffTextEditor supports double-click based application of edits from one
// buffer to the other.
func NewDiffTextEditor(parent ...tree.Node) *DiffTextEditor {
	return tree.New[DiffTextEditor](parent...)
}

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/texteditor.Editor", IDName: "editor", Doc: "Editor is a widget for editing multiple lines of complicated text (as compared to\n[core.TextField] for a single line of simple text).  The Editor is driven by a [Buffer]\nbuffer which contains all the text, and manages all the edits,\nsending update events out to the editors.\n\nUse NeedsRender to drive an render update for any change that does\nnot change the line-level layout of the text.\nUse NeedsLayout whenever there are changes across lines that require\nre-layout of the text.  This sets the Widget NeedsRender flag and triggers\nlayout during that render.\n\nMultiple editors can be attached to a given buffer.  All updating in the\nEditor should be within a single goroutine, as it would require\nextensive protections throughout code otherwise.", Directives: []types.Directive{{Tool: "core", Directive: "embedder"}}, Methods: []types.Method{{Name: "Lookup", Doc: "Lookup attempts to lookup symbol at current location, popping up a window\nif something is found.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Buffer", Doc: "Buffer is the text buffer being edited."}, {Name: "CursorWidth", Doc: "CursorWidth is the width of the cursor.\nThis should be set in Stylers like all other style properties."}, {Name: "LineNumberColor", Doc: "LineNumberColor is the color used for the side bar containing the line numbers.\nThis should be set in Stylers like all other style properties."}, {Name: "SelectColor", Doc: "SelectColor is the color used for the user text selection background color.\nThis should be set in Stylers like all other style properties."}, {Name: "HighlightColor", Doc: "HighlightColor is the color used for the text highlight background color (like in find).\nThis should be set in Stylers like all other style properties."}, {Name: "CursorColor", Doc: "CursorColor is the color used for the text editor cursor bar.\nThis should be set in Stylers like all other style properties."}, {Name: "NumLines", Doc: "NumLines is the number of lines in the view, synced with the [Buffer] after edits,\nbut always reflects the storage size of renders etc."}, {Name: "renders", Doc: "renders is a slice of paint.Text representing the renders of the text lines,\nwith one render per line (each line could visibly wrap-around, so these are logical lines, not display lines)."}, {Name: "offsets", Doc: "offsets is a slice of float32 representing the starting render offsets for the top of each line."}, {Name: "lineNumberDigits", Doc: "lineNumberDigits is the number of line number digits needed."}, {Name: "LineNumberOffset", Doc: "LineNumberOffset is the horizontal offset for the start of text after line numbers."}, {Name: "lineNumberRender", Doc: "lineNumberRender is the render for line numbers."}, {Name: "CursorPos", Doc: "CursorPos is the current cursor position."}, {Name: "cursorTarget", Doc: "cursorTarget is the target cursor position for externally set targets.\nIt ensures that the target position is visible."}, {Name: "cursorColumn", Doc: "cursorColumn is the desired cursor column, where the cursor was last when moved using left / right arrows.\nIt is used when doing up / down to not always go to short line columns."}, {Name: "posHistoryIndex", Doc: "posHistoryIndex is the current index within PosHistory."}, {Name: "selectStart", Doc: "selectStart is the starting point for selection, which will either be the start or end of selected region\ndepending on subsequent selection."}, {Name: "SelectRegion", Doc: "SelectRegion is the current selection region."}, {Name: "previousSelectRegion", Doc: "previousSelectRegion is the previous selection region that was actually rendered.\nIt is needed to update the render."}, {Name: "Highlights", Doc: "Highlights is a slice of regions representing the highlighted regions, e.g., for search results."}, {Name: "scopelights", Doc: "scopelights is a slice of regions representing the highlighted regions specific to scope markers."}, {Name: "LinkHandler", Doc: "LinkHandler handles link clicks.\nIf it is nil, they are sent to the standard web URL handler."}, {Name: "ISearch", Doc: "ISearch is the interactive search data."}, {Name: "QReplace", Doc: "QReplace is the query replace data."}, {Name: "selectMode", Doc: "selectMode is a boolean indicating whether to select text as the cursor moves."}, {Name: "fontHeight", Doc: "fontHeight is the font height, cached during styling."}, {Name: "lineHeight", Doc: "lineHeight is the line height, cached during styling."}, {Name: "fontAscent", Doc: "fontAscent is the font ascent, cached during styling."}, {Name: "fontDescent", Doc: "fontDescent is the font descent, cached during styling."}, {Name: "nLinesChars", Doc: "nLinesChars is the height in lines and width in chars of the visible area."}, {Name: "linesSize", Doc: "linesSize is the total size of all lines as rendered."}, {Name: "totalSize", Doc: "totalSize is the LinesSize plus extra space and line numbers etc."}, {Name: "lineLayoutSize", Doc: "lineLayoutSize is the Geom.Size.Actual.Total subtracting extra space and line numbers.\nThis is what LayoutStdLR sees for laying out each line."}, {Name: "lastlineLayoutSize", Doc: "lastlineLayoutSize is the last LineLayoutSize used in laying out lines.\nIt is used to trigger a new layout only when needed."}, {Name: "blinkOn", Doc: "blinkOn oscillates between on and off for blinking."}, {Name: "cursorMu", Doc: "cursorMu is a mutex protecting cursor rendering, shared between blink and main code."}, {Name: "hasLinks", Doc: "hasLinks is a boolean indicating if at least one of the renders has links.\nIt determines if we set the cursor for hand movements."}, {Name: "hasLineNumbers", Doc: "hasLineNumbers indicates that this editor has line numbers\n(per [Buffer] option)"}, {Name: "needsLayout", Doc: "needsLayout is set by NeedsLayout: Editor does significant\ninternal layout in LayoutAllLines, and its layout is simply based\non what it gets allocated, so it does not affect the rest\nof the Scene."}, {Name: "lastWasTabAI", Doc: "lastWasTabAI indicates that last key was a Tab auto-indent"}, {Name: "lastWasUndo", Doc: "lastWasUndo indicates that last key was an undo"}, {Name: "targetSet", Doc: "targetSet indicates that the CursorTarget is set"}, {Name: "lastRecenter"}, {Name: "lastAutoInsert"}, {Name: "lastFilename"}}})

// NewEditor returns a new [Editor] with the given optional parent:
// Editor is a widget for editing multiple lines of complicated text (as compared to
// [core.TextField] for a single line of simple text).  The Editor is driven by a [Buffer]
// buffer which contains all the text, and manages all the edits,
// sending update events out to the editors.
//
// Use NeedsRender to drive an render update for any change that does
// not change the line-level layout of the text.
// Use NeedsLayout whenever there are changes across lines that require
// re-layout of the text.  This sets the Widget NeedsRender flag and triggers
// layout during that render.
//
// Multiple editors can be attached to a given buffer.  All updating in the
// Editor should be within a single goroutine, as it would require
// extensive protections throughout code otherwise.
func NewEditor(parent ...tree.Node) *Editor { return tree.New[Editor](parent...) }

// EditorEmbedder is an interface that all types that embed Editor satisfy
type EditorEmbedder interface {
	AsEditor() *Editor
}

// AsEditor returns the given value as a value of type Editor if the type
// of the given value embeds Editor, or nil otherwise
func AsEditor(n tree.Node) *Editor {
	if t, ok := n.(EditorEmbedder); ok {
		return t.AsEditor()
	}
	return nil
}

// AsEditor satisfies the [EditorEmbedder] interface
func (t *Editor) AsEditor() *Editor { return t }

// SetCursorWidth sets the [Editor.CursorWidth]:
// CursorWidth is the width of the cursor.
// This should be set in Stylers like all other style properties.
func (t *Editor) SetCursorWidth(v units.Value) *Editor { t.CursorWidth = v; return t }

// SetLineNumberColor sets the [Editor.LineNumberColor]:
// LineNumberColor is the color used for the side bar containing the line numbers.
// This should be set in Stylers like all other style properties.
func (t *Editor) SetLineNumberColor(v image.Image) *Editor { t.LineNumberColor = v; return t }

// SetSelectColor sets the [Editor.SelectColor]:
// SelectColor is the color used for the user text selection background color.
// This should be set in Stylers like all other style properties.
func (t *Editor) SetSelectColor(v image.Image) *Editor { t.SelectColor = v; return t }

// SetHighlightColor sets the [Editor.HighlightColor]:
// HighlightColor is the color used for the text highlight background color (like in find).
// This should be set in Stylers like all other style properties.
func (t *Editor) SetHighlightColor(v image.Image) *Editor { t.HighlightColor = v; return t }

// SetCursorColor sets the [Editor.CursorColor]:
// CursorColor is the color used for the text editor cursor bar.
// This should be set in Stylers like all other style properties.
func (t *Editor) SetCursorColor(v image.Image) *Editor { t.CursorColor = v; return t }

// SetLinkHandler sets the [Editor.LinkHandler]:
// LinkHandler handles link clicks.
// If it is nil, they are sent to the standard web URL handler.
func (t *Editor) SetLinkHandler(v func(tl *paint.TextLink)) *Editor { t.LinkHandler = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/texteditor.OutputBuffer", IDName: "output-buffer", Doc: "OutputBuffer is a [Buffer] that records the output from an [io.Reader] using\n[bufio.Scanner]. It is optimized to combine fast chunks of output into\nlarge blocks of updating. It also supports an arbitrary markup function\nthat operates on each line of output bytes.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Fields: []types.Field{{Name: "Output", Doc: "the output that we are reading from, as an io.Reader"}, {Name: "Buffer", Doc: "the [Buffer] that we output to"}, {Name: "Batch", Doc: "how much time to wait while batching output (default: 200ms)"}, {Name: "MarkupFunc", Doc: "optional markup function that adds html tags to given line of output -- essential that it ONLY adds tags, and otherwise has the exact same visible bytes as the input"}, {Name: "currentOutputLines", Doc: "current buffered output raw lines, which are not yet sent to the Buffer"}, {Name: "currentOutputMarkupLines", Doc: "current buffered output markup lines, which are not yet sent to the Buffer"}, {Name: "mu", Doc: "mutex protecting updating of CurrentOutputLines and Buffer, and timer"}, {Name: "lastOutput", Doc: "time when last output was sent to buffer"}, {Name: "afterTimer", Doc: "time.AfterFunc that is started after new input is received and not immediately output -- ensures that it will get output if no further burst happens"}}})

// SetOutput sets the [OutputBuffer.Output]:
// the output that we are reading from, as an io.Reader
func (t *OutputBuffer) SetOutput(v io.Reader) *OutputBuffer { t.Output = v; return t }

// SetBuffer sets the [OutputBuffer.Buffer]:
// the [Buffer] that we output to
func (t *OutputBuffer) SetBuffer(v *Buffer) *OutputBuffer { t.Buffer = v; return t }

// SetBatch sets the [OutputBuffer.Batch]:
// how much time to wait while batching output (default: 200ms)
func (t *OutputBuffer) SetBatch(v time.Duration) *OutputBuffer { t.Batch = v; return t }

// SetMarkupFunc sets the [OutputBuffer.MarkupFunc]:
// optional markup function that adds html tags to given line of output -- essential that it ONLY adds tags, and otherwise has the exact same visible bytes as the input
func (t *OutputBuffer) SetMarkupFunc(v OutputBufferMarkupFunc) *OutputBuffer {
	t.MarkupFunc = v
	return t
}

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/texteditor.TwinEditors", IDName: "twin-editors", Doc: "TwinEditors presents two side-by-side [Editor]s in [core.Splits]\nthat scroll in sync with each other.", Embeds: []types.Field{{Name: "Splits"}}, Fields: []types.Field{{Name: "BufferA", Doc: "[Buffer] for A"}, {Name: "BufferB", Doc: "[Buffer] for B"}, {Name: "inInputEvent"}}})

// NewTwinEditors returns a new [TwinEditors] with the given optional parent:
// TwinEditors presents two side-by-side [Editor]s in [core.Splits]
// that scroll in sync with each other.
func NewTwinEditors(parent ...tree.Node) *TwinEditors { return tree.New[TwinEditors](parent...) }

// SetBufferA sets the [TwinEditors.BufferA]:
// [Buffer] for A
func (t *TwinEditors) SetBufferA(v *Buffer) *TwinEditors { t.BufferA = v; return t }

// SetBufferB sets the [TwinEditors.BufferB]:
// [Buffer] for B
func (t *TwinEditors) SetBufferB(v *Buffer) *TwinEditors { t.BufferB = v; return t }
